{"meta":{"title":"Voice of Eccentric","subtitle":"","description":"一个怪人的漫谈","author":"WANG JING","url":"https://jhin1018.github.io","root":"/"},"pages":[{"title":"","date":"2022-09-06T01:54:12.578Z","updated":"2022-09-06T01:54:12.578Z","comments":false,"path":"about/index.html","permalink":"https://jhin1018.github.io/about/index.html","excerpt":"","text":"一个奇怪的人"},{"title":"所有分类","date":"2022-09-06T01:57:39.197Z","updated":"2022-09-06T01:54:12.578Z","comments":true,"path":"categories/index.html","permalink":"https://jhin1018.github.io/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2022-09-06T03:26:19.509Z","updated":"2022-09-06T01:54:12.578Z","comments":true,"path":"tags/index.html","permalink":"https://jhin1018.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"未来两年计划","slug":"future-plan","date":"2022-09-06T02:04:28.000Z","updated":"2022-09-06T03:47:11.378Z","comments":true,"path":"2022/09/06/future-plan/","link":"","permalink":"https://jhin1018.github.io/2022/09/06/future-plan/","excerpt":"","text":"未来两年学习计划22年9月至23年2月：技术学习以快速适应工作岗位为主要目标，为了半年后的职级评定要多积累技术，学习主要以读书做笔记的形式。 暂定的小目标是每个月读完一本技术书籍，书单如下： 9月：《深入浅出NodeJS》&amp; 《ES6标准入门》。 10月：《Effective Typescript》（中英文版对照） 11月：《数据密集型应用系统设计》 12月：《代码整洁之道》 1月和2月暂时没想到要读什么书，先空着吧。如果有空闲的时间，可以阅读《JavaScript高级程序设计》，这本书比较厚实可能两个月都无法读完，一般当做工具书，有不懂的知识就可以查阅一下。 23年3月至8月：GT关这个阶段以攻克GRE为主要目标，由于一边工作一边准备GRE想必会十分辛苦，所以时间放的比较久，但是做计划的时候要做的紧一些，于是计划是两个月背单词，两个月刷题，尽量在6月前考出320+（够用就行）。 杀完G需要紧锣密鼓进入备考托福的阶段，托福的阅读写作在杀完G以后就比较简单，听力需要多刷题，对于我来说最难的是口语的部分，到时候可能需要上个冲刺班解决口语分数问题，T的要求是能上100，最好105+。 23年9月至24年2月： 继续积累技术23年下半年至24年2月会伴随着申请和可能存在的多次刷托福的情况，当然还有工作上的压力，想必是十分忙碌的。但是技术上的积累也是必须的，这个阶段暂时不了解我会对哪些技术有需求，目前想到的大概是四种路线： 深挖Node相关技术栈：阅读mongodb、redis、rabbitmq相关书籍和源码 学习前端：CSS、React、Vue等 学习Java技术栈：MySQL、SpringBoot 移动端大前端技术：Flutter、Uniapp等 24年3月至8月24月3月起就是offer季，从收到offer开始就可以准备离职了（乐）。但是这个阶段依然有许多的杂事，例如办签证。 依旧不能放松学习，除了继续积累上面提到的各种技术路线，最重要的是要重启LeetCode刷题计划，为在美国8月底和9月的秋招找实习做准备，目标是大厂offer。（当然我的Node技术栈可能导致在中小厂也有收获） 3-6月：每日一题。写题解的时候要开始习惯用英语写，这样面试时沟通会没有障碍。 7-8月：旅游/放松的同时，要按照知识点整理写过的LeetCode题目。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://jhin1018.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"plans","slug":"plans","permalink":"https://jhin1018.github.io/tags/plans/"}]},{"title":"Hello World","slug":"hello-world","date":"2022-09-06T01:54:12.577Z","updated":"2022-09-06T01:54:12.577Z","comments":true,"path":"2022/09/06/hello-world/","link":"","permalink":"https://jhin1018.github.io/2022/09/06/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"刷题日记 day7","slug":"codediaryday7","date":"2021-05-08T17:03:17.000Z","updated":"2022-09-06T01:54:12.577Z","comments":true,"path":"2021/05/09/codediaryday7/","link":"","permalink":"https://jhin1018.github.io/2021/05/09/codediaryday7/","excerpt":"","text":"LeetCode 1723 Find Minimum Time to Finish All Jobs今天的每日一题，体感是hard中也比较难的题目，放个官方题解链接以后再消化吧。官方题解 LeetCode 25 Reverse Nodes in k-Group虽然也是hard题，但是面试常考，所以研究一下。 思路翻转一个链表并不难，可以看day3解反转链表的思路。这道题最复杂的是长度为k的子链表翻转后如何再接回原链表中。首先先来写这个翻转子链表的函数，这个函数和普通的翻转链表没啥不同，只需要考虑几个细节即可。接下来我们就要考虑翻转后的子链表如何接回原链表中。在每次翻转k个节点之前，我们需要一个pre节点来保存子链表的前一个节点，和一个next 节点保存子链表的后一个节点，这样就可以接回去了。那么问题又来了，第一个节点前面没有怎么办？我们就人为的给第一个节点前面加上hair，这样就可以保持整个循环结构中的一致性，而且还有另一个好处，那就是hair.next一直指向这个翻转过的链表的头结点。至此，所有的问题都解决了。 Code1234567891011121314151617181920212223242526272829303132333435363738public ListNode reverseKGroup(ListNode head, int k) &#123; ListNode hair= new ListNode(0); hair.next = head; ListNode pre =hair;//子链表的前一个节点 while(head !=null)&#123; ListNode tail = pre; for(int i=0;i&lt;k;i++)&#123;//从上一次的尾巴往前走k步，和从head走k-1步一样 tail = tail.next; if(tail == null)&#123; return hair.next;//最后不足k个不需要翻转 &#125; &#125; ListNode next = tail.next;//子链表的后一个节点 ListNode[] subchain = myreverse(head,tail);//子链表翻转 head = subchain[0];//翻转后的头 tail = subchain[1];//翻转后的尾 pre.next = head;//子链表的前一个节点接上新的头 tail.next = next;//尾巴接上原本的后一个节点，其实在myreverse函数中已经接好了，这一行可有可无的 pre = tail;//对于下一个循环中的子链表，这一次的尾巴就是下一次的pre head = next; &#125; return hair.next;&#125;public ListNode[] myreverse(ListNode head,ListNode tail)&#123; ListNode prev = tail.next;//翻转链表中这里是null，而初始的prev表示head在翻转后应指向的节点，所以是tail的next ListNode cur = head; while(prev != tail)&#123;//留意这个循环终止条件，和反转链表不同 ListNode next = cur.next; cur.next = prev; prev = cur; cur = next; &#125; return new ListNode[]&#123;tail,head&#125;;// 翻转后head和tail互换&#125; 时间复杂度:O(n) 空间复杂度:O(1)","categories":[{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]},{"title":"刷题日记 day6","slug":"codediaryday6","date":"2021-05-07T04:17:37.000Z","updated":"2022-09-06T01:54:12.577Z","comments":true,"path":"2021/05/07/codediaryday6/","link":"","permalink":"https://jhin1018.github.io/2021/05/07/codediaryday6/","excerpt":"","text":"LeetCode 1486. XOR Operation in an Array思路今日的每日一题又是简单题，重拳出击！模拟一遍思路即可过，至于题解里面复杂的数学知识我选择无视。 Code12345678910public int xorOperation(int n, int start) &#123; int[] nums =new int[n]; for(int i=0;i&lt;n;i++)&#123; nums[i] =start +2*i; &#125; for(int i=1;i&lt;n;i++)&#123; start = start ^ nums[i]; &#125; return start;&#125; LeetCode 3 Longest Substring Without Repeating Characters思路不是第一次做了，去年为了学cpp刷题的时候就做过，思路还是和去年一样，使用滑动窗口法。用两个指针指向字符串中的位置，右边的指针不断增大，当右指针指向的字符已经在子串中出现过时，就将左指针不断向右移动，直到两个指针中间的子串无重复字母为止。 Code1234567891011121314151617public int lengthOfLongestSubstring(String s) &#123; if(s.length()==0 || s==null) return 0; if(s.length()==1) return 1; int len = s.length(); Map&lt;Character,Integer&gt; map =new HashMap&lt;Character,Integer&gt;(); int maxLength = 0; int left = 0; for(int i=0;i&lt;len;i++)&#123; if(map.containsKey(s.charAt(i)))&#123;//字符已经在子串中出现过 int c = map.get(s.charAt(i)); left = Math.max(left,c+1); &#125; map.put(s.charAt(i),i); maxLength = Math.max(maxLength,i-left +1); &#125; return maxLength;&#125; 时间复杂度：O(n) 遍历一遍字符串 空间复杂度：O(n) 需要将字符串中的每个字符都存到map中 LeetCode 1 Two Sum思路去年也做过了，思路至今印象深刻，使用哈希表，key为nums[i]，value为下标，一边遍历一边查找target-nums[i]，遍历不到一遍数组就能解答。 Code12345678910public int[] twoSum(int[] nums, int target) &#123; Map&lt;Integer,Integer&gt; map = new HashMap&lt;Integer,Integer&gt;(); for(int i=0;i&lt;nums.length;i++)&#123; if (map.containsKey(target-nums[i]))&#123; return new int[]&#123;map.get(target-nums[i]),i&#125;; &#125; map.put(nums[i],i); &#125; return new int[0];&#125; 时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。 空间复杂度：O(N)，其中 N是数组中的元素数量。主要为哈希表的开销。 LeetCode 15 3Sum思路从两数之和到三数之和，因为要求找出所有的不重复的三个数的和为0的集合，所以难度陡然上升。我一开始的思路是这样的，先排序，然后固定第一个数，接下来就是两数之和了。但是这个思路的问题在于两数之和有且仅有一个解答，而这道题里不止一个解，因此需要优化。受到前面滑动窗口思路的影响，我在固定第一个数以后，对于剩下的数组用两个指针，一个从前往后，另一个从后往前遍历，这样可以找出所有的解了。 Code123456789101112131415161718192021222324252627282930313233343536public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123; List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;(); if(nums==null|| nums.length&lt;=2) return res; int len = nums.length; Arrays.sort(nums); for(int first =0;first&lt;len-2;first++)&#123; if(nums[first]&gt;0) break; if (first&gt;0 &amp;&amp; nums[first]==nums[first-1]) continue;//保证第一个数字不重复 int target = -nums[first]; int second = first + 1; int third = len- 1; while(second &lt; third)&#123; if(nums[second] + nums[third] == target)&#123; List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(nums[first]); list.add(nums[second]); list.add(nums[third]); res.add(list); second++; third--; while(second&lt;third &amp;&amp; nums[second]==nums[second-1]) second++;//如果有重复就继续往后 while(second&lt;third &amp;&amp; nums[third]==nums[third+1]) third--;//有重复则继续往前 &#125; else if(nums[second] + nums[third] &lt; target)&#123; second++; &#125; else&#123; third--; &#125; &#125; &#125; return res; &#125; LeetCode 53 Maximum Subarray剑指Offer42，上个月做笔试的时候遇到3次，一次是原题，两次是变种，今天来整理一下思路增强应对变形题的能力。 思路记得第一次在笔试中遇到这个题目，我的思路十分简单就是暴力搜索，我按照某个节点开头为标杆搜索了所有可能的子序列。然后今天我在看题解的时候，看到了这一篇感觉对我十分有启发，详细解读动态规划的实现。这篇题解中归纳了三种遍历子序列的方式，我在下面复述一下，例子是[a,b,c,d,e]。 以某个节点为开头的子序列，[a],[a,b],[a,b,c]….然后是[b],[b,c],[b,c,d]…. 根据长度遍历子序列，先遍历长度为1的子序列，再遍历长度为2的… 以子序列的结束节点为基准遍历，例如以a为结束节点的子序列有[a],以b为结束节点的子序列有[b],[a,b]。 对于方法三，我们不难想到{以某个节点为结束的子序列集合}={以上一节点为结束的子序列加上该节点} +{该节点本身},这就形成了一种递推的关系，这样就有了使用动态规划来解决的思路基础。 于是回到这道题中，这道题动态规划的状态转移方程也就可以用这个思路得出，设f(i)是第i个节点的最大子序列和，那么f(i+1)=Max{f(i)+nums[i+1],nums[i+1]}。考察一下起始条件，f(0) =nums[0] Code12345678910111213public int maxSubArray(int[] nums) &#123; if(nums ==null || nums.length==0) return 0; if(nums.length ==1) return nums[0]; int len = nums.length; int[] f= new int[len]; f[0]=nums[0]; int max = f[0]; for(int i=1;i&lt;len;i++)&#123; f[i] =Math.max(f[i-1]+nums[i],nums[i]); max = Math.max(max,f[i]); &#125; return max;&#125; 时间复杂度:O(n)只遍历了一遍数组 空间复杂度:O(n) 储存了一个长度为n的f(n) 空间复杂度还可以优化，因为每个f(i)显然只和f(i-1)有关，因此我们可以考虑滚动数组的方式来优化。 123456789101112public int maxSubArray(int[] nums) &#123; if(nums ==null || nums.length==0) return 0; if(nums.length ==1) return nums[0]; int pre =nums[0]; int max = pre; for(int i=1;i&lt;nums.length;i++)&#123; int cur =Math.max(pre+nums[i],nums[i]); max = Math.max(max,cur); pre =cur; &#125; return max;&#125; 空间复杂度:O(1) LeetCode 121 Best Time to Buy and Sell Stock思路这题本质上就是上一题，我们求一个两天间价格差值的数组，然后把他丢给上一题解决，如果求出来最大子序列和小于0就返回0，于是就有了下面解法一的做法。但是解法一空间太浪费了，函数调用也造成时间的浪费。于是我们考虑更简单的解法，我们需要维护一个当前时间节点历史最小价格，然后收益即为当前价格-当前历史最小值，这个收益就类似于上一题中f(i),因此是可以用滚动数组优化的，于是解法二就出来了。 Code解法一1234567891011121314151617181920212223public int maxProfit(int[] prices) &#123; if(prices.length ==1) return 0; int len = prices.length; int[] d=new int[len-1]; for(int i=1;i&lt;len;i++)&#123; d[i-1] = prices[i]-prices[i-1]; &#125; int res = maxSubArray(d); return res&gt;0?res:0;&#125;public int maxSubArray(int[] nums) &#123; if(nums ==null || nums.length==0) return 0; if(nums.length ==1) return nums[0]; int pre =nums[0]; int max = pre; for(int i=1;i&lt;nums.length;i++)&#123; int cur =Math.max(pre+nums[i],nums[i]); max = Math.max(max,cur); pre =cur; &#125; return max;&#125; 解法二123456789101112public int maxProfit(int[] prices) &#123; if(prices.length ==1) return 0; int len = prices.length; int min =prices[0]; int max =0; for(int i=1;i&lt;len;i++)&#123; min =Math.min(min,prices[i]); max =Math.max(max,prices[i]-min); &#125; return max;&#125; 时间复杂度O(n) 空间复杂度O(1)","categories":[{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]},{"title":"刷题日记 day5","slug":"codediaryday5","date":"2021-05-05T16:20:14.000Z","updated":"2022-09-06T01:54:12.577Z","comments":true,"path":"2021/05/06/codediaryday5/","link":"","permalink":"https://jhin1018.github.io/2021/05/06/codediaryday5/","excerpt":"","text":"LeetCode 1720 Decode XORed Array思路今日每日一题，简单题重拳出击！解码异或数组，其实很简单，只需要知道若a XOR b =c，则c XOR a =b即可，既然encoded[i]=arr[i] XOR arr[i+1],那么arr[i+1] = encoded[i] XOR a[i],即arr[i] = encoded[i-1] XOR arr[i-1] Code12345678public int[] decode(int[] encoded, int first) &#123; int[] res = new int[encoded.length+1]; res[0] =first; for(int i=1;i&lt;res.length;i++)&#123; res[i] =res[i-1]^encoded[i-1]; &#125; return res; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]},{"title":"刷题日记 day4","slug":"codediaryday4","date":"2021-05-05T03:18:00.000Z","updated":"2022-09-06T01:54:12.577Z","comments":true,"path":"2021/05/05/codediaryday4/","link":"","permalink":"https://jhin1018.github.io/2021/05/05/codediaryday4/","excerpt":"","text":"LeetCode 198 House Robber思路比较典型的动态规划题目，主要思路如下。对于第K间屋子，如果不偷它，收益为前K-1间屋子的收益；如果偷它，收益为前K-2间屋子的收益+第K间屋子的收益。于是乎动态转移方程就得到了: dp[i] =max(dp[i-1],dp[i-2]+nums[i]) 同时考虑一下初始条件，如果只有一件屋子，那就是只有这一件屋子的收益；如果有两间屋子，那就是选择这两间屋子中收益大的那个。 Code1234567891011121314public int rob(int[] nums) &#123; if(nums.length==0 || nums ==null)&#123; return 0; &#125; int l = nums.length; if(l==1) return nums[0]; int[] dp = new int[l]; dp[0] =nums[0]; dp[1] =Math.max(nums[0],nums[1]); for(int i=2;i&lt;l;i++)&#123; dp[i] = Math.max(dp[i-1],dp[i-2]+nums[i]); &#125; return dp[l-1];&#125; 时间负责度：O(n) 空间复杂度：O(n) 实际上因为对于第k间屋子来说只需要看前k-1和前k-2的收益，所以可以把dp数组优化为滚动数组。 123456789101112131415public int rob(int[] nums) &#123; if(nums.length==0 || nums ==null)&#123; return 0; &#125; int l = nums.length; if(l==1) return nums[0]; int first =nums[0]; int second =Math.max(nums[0],nums[1]); for(int i=2;i&lt;l;i++)&#123; int temp = second; second = Math.max(second,first+nums[i]); first = temp; &#125; return second;&#125; 空间复杂度：O(1) 但很神秘的是，优化以后内存消耗变多了？？？目前推测中间交换时使用新变量temp导致内存消耗变大。 LeetCode 213 House Robber II思路上一题的升级版，加入了首尾相连的限制条件，导致第一间和最后一间房子不能同时抢了。由于这个限制条件并没有为这个问题增加新的维度，而是多了两种需要讨论的情况，一种是必须有第一间房子，另一种是必须有最后一间房子，那么思路已经很清晰了，就是做两遍DP，第一遍是从0-n-1，第二遍是从1-n，而这两遍dp的过程，单独来看就和上一题的过程相同。 Code1234567891011121314151617181920212223class Solution &#123; public int rob(int[] nums) &#123; if(nums.length==0 || nums ==null)&#123; return 0; &#125; if(nums.length==1) return nums[0]; return Math.max( myrob(Arrays.copyOfRange(nums, 0, nums.length-1)), myrob(Arrays.copyOfRange(nums, 1, nums.length))); &#125; public int myrob(int[] nums) &#123; int first =0; int second =0; int temp =0; for(int i:nums)&#123; temp = second; second = Math.max(second,first+i); first = temp; &#125; return second; &#125;&#125; 代码里的myrob函数再次优化了上一题中的滚动数组，考虑dp[-1]和dp[-2]，那么当这两个为0时， 对于第一间和第二间房子也可以直接套用状态转移公式。 JAVA知识java Arrays.copyOfRange的使用方法 original：第一个参数为要拷贝的数组对象 from：第二个参数为拷贝的开始位置（包含） to：第三个参数为拷贝的结束位置（不包含） 该方法的源代码中的实现是使用了System.arraycopy数组拷贝方法，同时为了防止越界，只会拷贝from位置到源数组最后一个元素。 LeetCode 740 Delete and Earn思路今天的每日一题，这道题可以转化成198。因为选择了x就不能选择x-1和x+1，这个条件就等同于198中的不能选择相邻两个。那么我们只要题目给的数组，转化为代表着数字x的权重数组即可。 例如官方例子nums = [2,2,3,3,3,4] 我们将其转化为sum=[0,0,4,9,4]。sum数组代表数组下标在nums中出现的次数×下标的大小，即2在nums中出现2次，于是sum[2]=2×2;3在nums中出现3次，于是sum[3]=3×3等等 然后我们就可以把sum交给198的函数了。 Code12345678910111213141516171819202122232425class Solution &#123; public int deleteAndEarn(int[] nums) &#123; int maxVal = 0; for(int i:nums)&#123; maxVal =Math.max(maxVal,i); &#125; int[] sum = new int[maxVal+1]; for(int i :nums)&#123; sum[i] +=i; &#125; return rob(sum); &#125; public int rob(int[] nums) &#123; int first =0; int second =0; int temp =0; for(int i:nums)&#123; temp = second; second = Math.max(second,first+i); first = temp; &#125; return second; &#125;&#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]},{"title":"刷题日记day3","slug":"codediaryday3","date":"2021-05-04T14:49:18.000Z","updated":"2022-09-06T01:54:12.576Z","comments":true,"path":"2021/05/04/codediaryday3/","link":"","permalink":"https://jhin1018.github.io/2021/05/04/codediaryday3/","excerpt":"","text":"LeetCode 每日一题 1473 粉刷房子 III这道hard的题目，要用到三维dp，对于我现在来说还是太难了，这里放个题解连接后面慢慢消化。 题解 LeetCode 206 反转链表面试常考题，上次网易面试里也被考到了，我给了一个用栈来实现的解答，面试官的反馈来看感觉空间复杂度不够满意，今天来学习一下优秀的思路。 主要的思路就是用三个指针，分别指向当前节点、前一个节点、后一个节点。然后把当前节点的next改为pre，然后向前移动当前节点的指针并更新另外两个指针相应位置。 1234567891011public ListNode reverseList(ListNode head) &#123; ListNode pre &#x3D; null; ListNode curr &#x3D; head; while (curr !&#x3D; null) &#123; ListNode next &#x3D; curr.next;\\\\保存当前节点的后一个节点，不然没法向前移动 curr.next &#x3D; pre;&#x2F;&#x2F;翻转 pre &#x3D; curr;&#x2F;&#x2F;向前移动当前节点指针前先移动前一个节点的指针，让它指向当前节点 curr &#x3D; next; &#125; return pre; &#125; 时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。 空间复杂度：O(1)。","categories":[{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]},{"title":"刷题日记day2","slug":"codeday2","date":"2021-05-03T12:17:01.000Z","updated":"2022-09-06T01:54:12.576Z","comments":true,"path":"2021/05/03/codeday2/","link":"","permalink":"https://jhin1018.github.io/2021/05/03/codeday2/","excerpt":"","text":"每日一题 LeetCode 7 翻转整数说实话这个题目太过简单，只需要考虑溢出时的情况，不过这里有趣的是C++溢出时会报错而Java不会，因此java中只需要判断每次乘10加上个位数字后再整除10还等不等于原数的情况，如果不等那就是溢出了，溢出就返回0。 Code： 123456789101112public int reverse(int x) &#123; int res &#x3D; 0; while (x !&#x3D; 0) &#123; int tmp &#x3D; res * 10 + x % 10; if (tmp &#x2F; 10 !&#x3D; res) &#123; &#x2F;&#x2F; 溢出 return 0; &#125; res &#x3D; tmp; x &#x2F;&#x3D; 10; &#125; return res; &#125;","categories":[{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]},{"title":"刷题日记day1 —— LeetCode 554 砖墙","slug":"codeday1","date":"2021-05-03T06:33:03.000Z","updated":"2022-09-06T01:54:12.576Z","comments":true,"path":"2021/05/03/codeday1/","link":"","permalink":"https://jhin1018.github.io/2021/05/03/codeday1/","excerpt":"","text":"每日一题 LeetCode 554思路一最初想法，模拟整个砖墙，用一个二维数组储存整个墙，然后判断各个缝隙。 12345678910111213141516171819202122232425262728293031public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) &#123; int height = wall.size(); int width =0; for(int i:wall.get(1))&#123; width += i; &#125; if(width ==1) &#123; return height;&#125; int[][] map = new int[height][width]; for(int i=0;i&lt;height;i++)&#123; List&lt;Integer&gt; line = wall.get(i); int l =0; int num =0; for(int j:line)&#123; int end =l+j; for(;l&lt;end;l++)&#123; map[i][l] =num; &#125; num ++; &#125; &#125; int res =height; for(int i=0;i&lt;width-1;i++)&#123; int cnt =0; for(int j=0;j&lt;height;j++)&#123; if(map[j][i] ==map[j][i+1])cnt++; &#125; res =Math.min(res,cnt); &#125; return res; &#125; 结果：内存爆了，输入为[[100000000],[100000000],[100000000]] 思路二从刚才的思路里可以发现，我们用这个二维数组主要保存的信息是每一行砖块之间的缝隙，因此我们可以考虑用哈希表来记录这样一对数据&lt;从左往右缝隙出现的距离，从上到下该距离上有缝隙的次数&gt;,考虑到穿过的最小的砖块数=行数-缝隙出现的最大次数，所以可以得到解答。 Code： 123456789101112131415161718192021222324public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) &#123; Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;Integer,Integer&gt;(); for(List&lt;Integer&gt; list:wall)&#123; int cur &#x3D; 0; for(int i&#x3D;0;i&lt;list.size()-1;i++)&#123; cur+&#x3D;list.get(i);&#x2F;&#x2F;缝隙从左到右的距离 if(map.containsKey(cur))&#123;&#x2F;&#x2F;如果该距离上出现过缝隙 map.put(cur,map.get(cur)+1);&#x2F;&#x2F;给value+1 &#125;else&#123; map.put(cur,1);&#x2F;&#x2F;该距离上第一次出现缝隙 &#125; &#125; &#125; int max &#x3D; 0; for(Map.Entry&lt;Integer, Integer&gt; entry:map.entrySet())&#123; max &#x3D; max&gt;entry.getValue()?max:entry.getValue(); &#125; return wall.size()-max;&#125; 知识点总结HashMap中的EntryHashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。","categories":[{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]}],"categories":[{"name":"随笔","slug":"随笔","permalink":"https://jhin1018.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"技术","slug":"技术","permalink":"https://jhin1018.github.io/categories/%E6%8A%80%E6%9C%AF/"}],"tags":[{"name":"plans","slug":"plans","permalink":"https://jhin1018.github.io/tags/plans/"},{"name":"LeetCode","slug":"LeetCode","permalink":"https://jhin1018.github.io/tags/LeetCode/"}]}