<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>刷题日记 day6</title>
      <link href="2021/05/07/codediaryday6/"/>
      <url>2021/05/07/codediaryday6/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-1486-XOR-Operation-in-an-Array"><a href="#LeetCode-1486-XOR-Operation-in-an-Array" class="headerlink" title="LeetCode 1486. XOR Operation in an Array"></a>LeetCode 1486. XOR Operation in an Array</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>今日的每日一题又是简单题，重拳出击！模拟一遍思路即可过，至于题解里面复杂的数学知识我选择无视。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">xorOperation</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] nums =<span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        nums[i] =start +<span class="number">2</span>*i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)&#123;</span><br><span class="line">        start = start ^ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-3-Longest-Substring-Without-Repeating-Characters"><a href="#LeetCode-3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="LeetCode 3 Longest Substring Without Repeating Characters"></a>LeetCode 3 Longest Substring Without Repeating Characters</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>不是第一次做了，去年为了学cpp刷题的时候就做过，思路还是和去年一样，使用滑动窗口法。用两个指针指向字符串中的位置，右边的指针不断增大，当右指针指向的字符已经在子串中出现过时，就将左指针不断向右移动，直到两个指针中间的子串无重复字母为止。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">0</span> || s==<span class="keyword">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(s.length()==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len = s.length();</span><br><span class="line">    Map&lt;Character,Integer&gt; map =<span class="keyword">new</span> HashMap&lt;Character,Integer&gt;();</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(map.containsKey(s.charAt(i)))&#123;<span class="comment">//字符已经在子串中出现过</span></span><br><span class="line">            <span class="keyword">int</span> c = map.get(s.charAt(i));</span><br><span class="line">            left = Math.max(left,c+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(s.charAt(i),i);</span><br><span class="line">        maxLength = Math.max(maxLength,i-left +<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(n) 遍历一遍字符串</li><li>空间复杂度：O(n) 需要将字符串中的每个字符都存到map中</li></ul><h2 id="LeetCode-1-Two-Sum"><a href="#LeetCode-1-Two-Sum" class="headerlink" title="LeetCode 1 Two Sum"></a>LeetCode 1 Two Sum</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>去年也做过了，思路至今印象深刻，使用哈希表，key为nums[i]，value为下标，一边遍历一边查找target-nums[i]，遍历不到一遍数组就能解答。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer,Integer&gt; map = <span class="keyword">new</span> HashMap&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(target-nums[i]))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(target-nums[i]),i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(N)，其中 N 是数组中的元素数量。对于每一个元素 x，我们可以 O(1) 地寻找 target - x。</p></li><li><p>空间复杂度：O(N)，其中 N是数组中的元素数量。主要为哈希表的开销。</p></li></ul><h2 id="LeetCode-15-3Sum"><a href="#LeetCode-15-3Sum" class="headerlink" title="LeetCode 15  3Sum"></a>LeetCode 15  3Sum</h2><h3 id="思路-3"><a href="#思路-3" class="headerlink" title="思路"></a>思路</h3><p>从两数之和到三数之和，因为要求找出所有的不重复的三个数的和为0的集合，所以难度陡然上升。我一开始的思路是这样的，先排序，然后固定第一个数，接下来就是两数之和了。但是这个思路的问题在于两数之和有且仅有一个解答，而这道题里不止一个解，因此需要优化。受到前面滑动窗口思路的影响，我在固定第一个数以后，对于剩下的数组用两个指针，一个从前往后，另一个从后往前遍历，这样可以找出所有的解了。</p><h3 id="Code-3"><a href="#Code-3" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="keyword">null</span>|| nums.length&lt;=<span class="number">2</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> first =<span class="number">0</span>;first&lt;len-<span class="number">2</span>;first++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[first]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (first&gt;<span class="number">0</span> &amp;&amp; nums[first]==nums[first-<span class="number">1</span>]) <span class="keyword">continue</span>;<span class="comment">//保证第一个数字不重复</span></span><br><span class="line">            <span class="keyword">int</span> target = -nums[first];</span><br><span class="line">            <span class="keyword">int</span> second = first + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> third = len- <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(second &lt; third)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[second] + nums[third] == target)&#123;</span><br><span class="line">                    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line">                    list.add(nums[first]);</span><br><span class="line">                    list.add(nums[second]);</span><br><span class="line">                    list.add(nums[third]);</span><br><span class="line">                    res.add(list);</span><br><span class="line"></span><br><span class="line">                    second++;</span><br><span class="line">                    third--;</span><br><span class="line">                    <span class="keyword">while</span>(second&lt;third &amp;&amp; nums[second]==nums[second-<span class="number">1</span>]) second++;<span class="comment">//如果有重复就继续往后</span></span><br><span class="line">                    <span class="keyword">while</span>(second&lt;third &amp;&amp; nums[third]==nums[third+<span class="number">1</span>]) third--;<span class="comment">//有重复则继续往前</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(nums[second] + nums[third] &lt; target)&#123;</span><br><span class="line">                    second++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    third--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="LeetCode-53-Maximum-Subarray"><a href="#LeetCode-53-Maximum-Subarray" class="headerlink" title="LeetCode 53 Maximum Subarray"></a>LeetCode 53 Maximum Subarray</h2><p>剑指Offer42，上个月做笔试的时候遇到3次，一次是原题，两次是变种，今天来整理一下思路增强应对变形题的能力。</p><h3 id="思路-4"><a href="#思路-4" class="headerlink" title="思路"></a>思路</h3><p>记得第一次在笔试中遇到这个题目，我的思路十分简单就是暴力搜索，我按照某个节点开头为标杆搜索了所有可能的子序列。然后今天我在看题解的时候，看到了这一篇感觉对我十分有启发，<a href="https://leetcode-cn.com/problems/maximum-subarray/solution/xiang-xi-jie-du-dong-tai-gui-hua-de-shi-xian-yi-li/">详细解读动态规划的实现</a>。这篇题解中归纳了三种遍历子序列的方式，我在下面复述一下，例子是[a,b,c,d,e]。</p><ul><li>以某个节点为开头的子序列，[a],[a,b],[a,b,c]….然后是[b],[b,c],[b,c,d]….</li><li>根据长度遍历子序列，先遍历长度为1的子序列，再遍历长度为2的…</li><li><strong>以子序列的结束节点为基准遍历</strong>，例如以a为结束节点的子序列有[a],以b为结束节点的子序列有[b],[a,b]。</li></ul><p>对于方法三，我们不难想到{以某个节点为结束的子序列集合}={以上一节点为结束的子序列加上该节点} +{该节点本身},这就形成了一种递推的关系，这样就有了使用动态规划来解决的思路基础。</p><p>于是回到这道题中，这道题动态规划的状态转移方程也就可以用这个思路得出，设f(i)是第i个节点的最大子序列和，那么f(i+1)=Max{f(i)+nums[i+1],nums[i+1]}。考察一下起始条件，f(0) =nums[0]</p><h3 id="Code-4"><a href="#Code-4" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums ==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length ==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    <span class="keyword">int</span>[] f= <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">    f[<span class="number">0</span>]=nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = f[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">    f[i] =Math.max(f[i-<span class="number">1</span>]+nums[i],nums[i]);</span><br><span class="line">    max = Math.max(max,f[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度:O(n)只遍历了一遍数组</li><li>空间复杂度:O(n) 储存了一个长度为n的f(n)</li></ul><p>空间复杂度还可以优化，因为每个f(i)显然只和f(i-1)有关，因此我们可以考虑滚动数组的方式来优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums ==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length ==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pre =nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> cur =Math.max(pre+nums[i],nums[i]);</span><br><span class="line">    max = Math.max(max,cur);</span><br><span class="line">    pre =cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>空间复杂度:O(1)</li></ul><h2 id="LeetCode-121-Best-Time-to-Buy-and-Sell-Stock"><a href="#LeetCode-121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="LeetCode 121 Best Time to Buy and Sell Stock"></a>LeetCode 121 Best Time to Buy and Sell Stock</h2><h3 id="思路-5"><a href="#思路-5" class="headerlink" title="思路"></a>思路</h3><p>这题本质上就是上一题，我们求一个两天间价格差值的数组，然后把他丢给上一题解决，如果求出来最大子序列和小于0就返回0，于是就有了下面解法一的做法。但是解法一空间太浪费了，函数调用也造成时间的浪费。于是我们考虑更简单的解法，我们需要维护一个当前时间节点历史最小价格，然后收益即为当前价格-当前历史最小值，这个收益就类似于上一题中f(i),因此是可以用滚动数组优化的，于是解法二就出来了。</p><h3 id="Code-5"><a href="#Code-5" class="headerlink" title="Code"></a>Code</h3><h4 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length ==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">int</span>[] d=<span class="keyword">new</span> <span class="keyword">int</span>[len-<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">    d[i-<span class="number">1</span>] = prices[i]-prices[i-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = maxSubArray(d);</span><br><span class="line">    <span class="keyword">return</span> res&gt;<span class="number">0</span>?res:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums ==<span class="keyword">null</span> || nums.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length ==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> pre =nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max = pre;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;nums.length;i++)&#123;</span><br><span class="line">    <span class="keyword">int</span> cur =Math.max(pre+nums[i],nums[i]);</span><br><span class="line">    max = Math.max(max,cur);</span><br><span class="line">    pre =cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(prices.length ==<span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = prices.length;</span><br><span class="line">    <span class="keyword">int</span> min =prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> max =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;len;i++)&#123;</span><br><span class="line">    min =Math.min(min,prices[i]);</span><br><span class="line">    max =Math.max(max,prices[i]-min);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>时间复杂度O(n)</li><li>空间复杂度O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题日记 day5</title>
      <link href="2021/05/06/codediaryday5/"/>
      <url>2021/05/06/codediaryday5/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-1720-Decode-XORed-Array"><a href="#LeetCode-1720-Decode-XORed-Array" class="headerlink" title="LeetCode 1720 Decode XORed Array"></a>LeetCode 1720 Decode XORed Array</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>今日每日一题，简单题重拳出击！解码异或数组，其实很简单，只需要知道若a XOR b =c，则c XOR a =b即可，既然encoded[i]=arr[i] XOR arr[i+1],那么arr[i+1] = encoded[i] XOR a[i],即arr[i] = encoded[i-1] XOR arr[i-1]</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span>[] decode(<span class="keyword">int</span>[] encoded, <span class="keyword">int</span> first) &#123;</span><br><span class="line">       <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[encoded.length+<span class="number">1</span>];</span><br><span class="line">       res[<span class="number">0</span>] =first;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;res.length;i++)&#123;</span><br><span class="line">           res[i] =res[i-<span class="number">1</span>]^encoded[i-<span class="number">1</span>];</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题日记 day4</title>
      <link href="2021/05/05/codediaryday4/"/>
      <url>2021/05/05/codediaryday4/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-198-House-Robber"><a href="#LeetCode-198-House-Robber" class="headerlink" title="LeetCode 198 House Robber"></a>LeetCode 198 House Robber</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>比较典型的动态规划题目，主要思路如下。对于第K间屋子，如果不偷它，收益为前K-1间屋子的收益；如果偷它，收益为前K-2间屋子的收益+第K间屋子的收益。于是乎动态转移方程就得到了:</p><ul><li>dp[i] =max(dp[i-1],dp[i-2]+nums[i])</li></ul><p>同时考虑一下初始条件，如果只有一件屋子，那就是只有这一件屋子的收益；如果有两间屋子，那就是选择这两间屋子中收益大的那个。</p><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums ==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(l==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[l];</span><br><span class="line">    dp[<span class="number">0</span>] =nums[<span class="number">0</span>];</span><br><span class="line">    dp[<span class="number">1</span>] =Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;l;i++)&#123;</span><br><span class="line">        dp[i] = Math.max(dp[i-<span class="number">1</span>],dp[i-<span class="number">2</span>]+nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[l-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间负责度：O(n)</li><li>空间复杂度：O(n)</li></ul><p>实际上因为对于第k间屋子来说只需要看前k-1和前k-2的收益，所以可以把dp数组优化为滚动数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums ==<span class="keyword">null</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> l = nums.length;</span><br><span class="line">    <span class="keyword">if</span>(l==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> first =nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> second =Math.max(nums[<span class="number">0</span>],nums[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;l;i++)&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = second;</span><br><span class="line">        second = Math.max(second,first+nums[i]);</span><br><span class="line">        first = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> second;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>空间复杂度：O(1)</li></ul><p>但很神秘的是，优化以后内存消耗变多了？？？目前推测中间交换时使用新变量temp导致内存消耗变大。</p><h2 id="LeetCode-213-House-Robber-II"><a href="#LeetCode-213-House-Robber-II" class="headerlink" title="LeetCode 213 House Robber II"></a>LeetCode 213 House Robber II</h2><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>上一题的升级版，加入了首尾相连的限制条件，导致第一间和最后一间房子不能同时抢了。由于这个限制条件并没有为这个问题增加新的维度，而是多了两种需要讨论的情况，一种是必须有第一间房子，另一种是必须有最后一间房子，那么思路已经很清晰了，就是做两遍DP，第一遍是从0-n-1，第二遍是从1-n，而这两遍dp的过程，单独来看就和上一题的过程相同。</p><h3 id="Code-1"><a href="#Code-1" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">0</span> || nums ==<span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(nums.length==<span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> Math.max(</span><br><span class="line">            myrob(Arrays.copyOfRange(nums, <span class="number">0</span>, nums.length-<span class="number">1</span>)),</span><br><span class="line">            myrob(Arrays.copyOfRange(nums, <span class="number">1</span>, nums.length)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">myrob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> second =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            temp = second;</span><br><span class="line">            second = Math.max(second,first+i);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里的myrob函数再次优化了上一题中的滚动数组，考虑dp[-1]和dp[-2]，那么当这两个为0时，</p><p>对于第一间和第二间房子也可以直接套用状态转移公式。</p><h3 id="JAVA知识"><a href="#JAVA知识" class="headerlink" title="JAVA知识"></a>JAVA知识</h3><p>java Arrays.copyOfRange的使用方法</p><ul><li>original：第一个参数为要拷贝的数组对象</li><li>from：第二个参数为拷贝的开始位置（包含）</li><li>to：第三个参数为拷贝的结束位置（不包含）</li></ul><p>该方法的源代码中的实现是使用了System.arraycopy数组拷贝方法，同时为了防止越界，只会拷贝from位置到源数组最后一个元素。</p><h2 id="LeetCode-740-Delete-and-Earn"><a href="#LeetCode-740-Delete-and-Earn" class="headerlink" title="LeetCode 740 Delete and Earn"></a>LeetCode 740 Delete and Earn</h2><h3 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h3><p>今天的每日一题，这道题可以转化成198。因为选择了x就不能选择x-1和x+1，这个条件就等同于198中的不能选择相邻两个。那么我们只要题目给的数组，转化为代表着数字x的权重数组即可。</p><p>例如官方例子nums = [2,2,3,3,3,4]</p><p>我们将其转化为sum=[0,0,4,9,4]。sum数组代表数组下标在nums中出现的次数×下标的大小，即2在nums中出现2次，于是sum[2]=2×2;3在nums中出现3次，于是sum[3]=3×3等等</p><p>然后我们就可以把sum交给198的函数了。</p><h3 id="Code-2"><a href="#Code-2" class="headerlink" title="Code"></a>Code</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            maxVal =Math.max(maxVal,i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] sum = <span class="keyword">new</span> <span class="keyword">int</span>[maxVal+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i :nums)&#123;</span><br><span class="line">            sum[i] +=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rob(sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> first =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> second =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> temp =<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i:nums)&#123;</span><br><span class="line">            temp = second;</span><br><span class="line">            second = Math.max(second,first+i);</span><br><span class="line">            first = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题日记day3</title>
      <link href="2021/05/04/codediaryday3/"/>
      <url>2021/05/04/codediaryday3/</url>
      
        <content type="html"><![CDATA[<h2 id="LeetCode-每日一题-1473-粉刷房子-III"><a href="#LeetCode-每日一题-1473-粉刷房子-III" class="headerlink" title="LeetCode 每日一题 1473 粉刷房子 III"></a>LeetCode 每日一题 1473 粉刷房子 III</h2><p>这道hard的题目，要用到三维dp，对于我现在来说还是太难了，这里放个题解连接后面慢慢消化。</p><p><a href="https://leetcode-cn.com/problems/paint-house-iii/solution/gong-shui-san-xie-san-wei-dong-tai-gui-h-ud7m/">题解</a></p><h2 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode 206 反转链表"></a>LeetCode 206 反转链表</h2><p>面试常考题，上次网易面试里也被考到了，我给了一个用栈来实现的解答，面试官的反馈来看感觉空间复杂度不够满意，今天来学习一下优秀的思路。</p><p>主要的思路就是用三个指针，分别指向当前节点、前一个节点、后一个节点。然后把当前节点的next改为pre，然后向前移动当前节点的指针并更新另外两个指针相应位置。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public ListNode reverseList(ListNode head) &#123;</span><br><span class="line">        ListNode pre &#x3D; null;</span><br><span class="line">        ListNode curr &#x3D; head;</span><br><span class="line">        while (curr !&#x3D; null) &#123;</span><br><span class="line">            ListNode next &#x3D; curr.next;\\保存当前节点的后一个节点，不然没法向前移动</span><br><span class="line">            curr.next &#x3D; pre;&#x2F;&#x2F;翻转</span><br><span class="line">            pre &#x3D; curr;&#x2F;&#x2F;向前移动当前节点指针前先移动前一个节点的指针，让它指向当前节点</span><br><span class="line">            curr &#x3D; next;</span><br><span class="line">        &#125;</span><br><span class="line">        return pre;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(n)，其中 n 是链表的长度。需要遍历链表一次。</p></li><li><p>空间复杂度：O(1)。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题日记day2</title>
      <link href="2021/05/03/codeday2/"/>
      <url>2021/05/03/codeday2/</url>
      
        <content type="html"><![CDATA[<h2 id="每日一题-LeetCode-7-翻转整数"><a href="#每日一题-LeetCode-7-翻转整数" class="headerlink" title="每日一题 LeetCode 7 翻转整数"></a>每日一题 LeetCode 7 翻转整数</h2><p>说实话这个题目太过简单，只需要考虑溢出时的情况，不过这里有趣的是C++溢出时会报错而Java不会，因此java中只需要判断每次乘10加上个位数字后再整除10还等不等于原数的情况，如果不等那就是溢出了，溢出就返回0。</p><p>Code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int reverse(int x) &#123;</span><br><span class="line">        int res &#x3D; 0;</span><br><span class="line">        while (x !&#x3D; 0) &#123;</span><br><span class="line">            int tmp &#x3D; res * 10 + x % 10;</span><br><span class="line">            if (tmp &#x2F; 10 !&#x3D; res) &#123; &#x2F;&#x2F; 溢出</span><br><span class="line">                return 0;</span><br><span class="line">            &#125;</span><br><span class="line">            res &#x3D; tmp;</span><br><span class="line">            x &#x2F;&#x3D; 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题日记day1 —— LeetCode 554 砖墙</title>
      <link href="2021/05/03/codeday1/"/>
      <url>2021/05/03/codeday1/</url>
      
        <content type="html"><![CDATA[<h1 id="每日一题-LeetCode-554"><a href="#每日一题-LeetCode-554" class="headerlink" title="每日一题 LeetCode 554"></a>每日一题 LeetCode 554</h1><h2 id="思路一"><a href="#思路一" class="headerlink" title="思路一"></a>思路一</h2><p>最初想法，模拟整个砖墙，用一个二维数组储存整个墙，然后判断各个缝隙。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">leastBricks</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; wall)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> height = wall.size();</span><br><span class="line">       <span class="keyword">int</span> width =<span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i:wall.get(<span class="number">1</span>))&#123;</span><br><span class="line">           width += i;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(width ==<span class="number">1</span>) &#123; <span class="keyword">return</span> height;&#125;</span><br><span class="line">       <span class="keyword">int</span>[][] map = <span class="keyword">new</span> <span class="keyword">int</span>[height][width];</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;height;i++)&#123;</span><br><span class="line">           List&lt;Integer&gt; line = wall.get(i);</span><br><span class="line">           <span class="keyword">int</span> l =<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">int</span> num =<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j:line)&#123;</span><br><span class="line">               <span class="keyword">int</span> end =l+j;</span><br><span class="line">               <span class="keyword">for</span>(;l&lt;end;l++)&#123;</span><br><span class="line">                   map[i][l] =num;</span><br><span class="line">               &#125;</span><br><span class="line">               num ++;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">int</span> res =height;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;width-<span class="number">1</span>;i++)&#123;</span><br><span class="line">           <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;height;j++)&#123;</span><br><span class="line">               <span class="keyword">if</span>(map[j][i] ==map[j][i+<span class="number">1</span>])cnt++;</span><br><span class="line">           &#125;</span><br><span class="line">           res =Math.min(res,cnt);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>结果：内存爆了，输入为[[100000000],[100000000],[100000000]]</p><h2 id="思路二"><a href="#思路二" class="headerlink" title="思路二"></a>思路二</h2><p>从刚才的思路里可以发现，我们用这个二维数组主要保存的信息是每一行砖块之间的缝隙，因此我们可以考虑用哈希表来记录这样一对数据&lt;从左往右缝隙出现的距离，从上到下该距离上有缝隙的次数&gt;,考虑到穿过的最小的砖块数=行数-缝隙出现的最大次数，所以可以得到解答。</p><p>Code：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int leastBricks(List&lt;List&lt;Integer&gt;&gt; wall) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; map &#x3D; new HashMap&lt;Integer,Integer&gt;(); </span><br><span class="line">        </span><br><span class="line">        for(List&lt;Integer&gt; list:wall)&#123;</span><br><span class="line">        int cur &#x3D; 0;</span><br><span class="line">        for(int i&#x3D;0;i&lt;list.size()-1;i++)&#123;</span><br><span class="line">        </span><br><span class="line">        cur+&#x3D;list.get(i);&#x2F;&#x2F;缝隙从左到右的距离</span><br><span class="line">        </span><br><span class="line">            if(map.containsKey(cur))&#123;&#x2F;&#x2F;如果该距离上出现过缝隙</span><br><span class="line">            map.put(cur,map.get(cur)+1);&#x2F;&#x2F;给value+1</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">            map.put(cur,1);&#x2F;&#x2F;该距离上第一次出现缝隙</span><br><span class="line">            &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int max &#x3D; 0;</span><br><span class="line">        for(Map.Entry&lt;Integer, Integer&gt; entry:map.entrySet())&#123;</span><br><span class="line">        max &#x3D; max&gt;entry.getValue()?max:entry.getValue();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return wall.size()-max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="知识点总结"><a href="#知识点总结" class="headerlink" title="知识点总结"></a>知识点总结</h1><h2 id="HashMap中的Entry"><a href="#HashMap中的Entry" class="headerlink" title="HashMap中的Entry"></a>HashMap中的Entry</h2><p>HashMap的主干是一个Entry数组。Entry是HashMap的基本组成单元，每一个Entry包含一个key-value键值对。</p>]]></content>
      
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/05/03/hello-world/"/>
      <url>2021/05/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
